{"version":3,"sources":["storage.ts"],"names":["chunkContent","content","_","chunk","split","map","join","sanitizeText","text","replace","trim","Storage","constructor","bp","botId","update","entry","KbEntry","validate","updated_on","Date","title","mapValues","arr","chain","flatten","uniq","value","filter","Boolean","data","fetch","x","id","push","ghost","forBot","upsertFile","JSON","stringify","undefined","_data","readFileAsObject","err","logger","attachError","warn","delete","ids","o","includes","getDataHash","entries","storeModel","model","toJSON","loadLatestModel","modelData","readFileAsString","length","Error","RemoteModel","fromJSON"],"mappings":"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","sourceRoot":"/mnt/Documents/Projets/BotPress/botpress/modules/kb/src/backend","sourcesContent":["import * as sdk from 'botpress/sdk'\nimport _ from 'lodash'\n\nimport RemoteModel from './model'\nimport { Entry, Model } from './typings'\nimport { KbEntry } from './validation'\n\nconst chunkContent = (content: string): string[] => {\n  return _.chunk(content.split(' '), 200).map(chunk => chunk.join(' '))\n  // if (content.length <= 1500) {\n  //   return [content]\n  // } else {\n  //   // split paragraphs\n  //   return content.split(/\\r|\\n/g).filter(Boolean)\n  // }\n}\n\n// upper case sentences\n// append ? to suffix\n// remove repeated special chars\n// typo fixes\n// expand contractions\n// quebec vocab\nexport const sanitizeText = (text: string) =>\n  (text || '')\n    .replace(/[\\r\\n]+/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim()\n\nexport default class Storage {\n  private bp: typeof sdk\n  public botId: string\n\n  private _data: Entry[] | null = null\n\n  constructor(bp: typeof sdk, botId: string) {\n    this.bp = bp\n    this.botId = botId\n  }\n\n  async update(entry: Entry): Promise<void> {\n    entry = await KbEntry.validate(entry)\n    entry.updated_on = new Date()\n    entry.title = _.mapValues(entry.title, title => sanitizeText(title))\n    entry.content = _.mapValues(entry.content, arr => {\n      return _.chain(arr)\n        .map(chunkContent)\n        .flatten()\n        .map(sanitizeText)\n        .uniq()\n        .value()\n        .filter(Boolean)\n    })\n\n    let data = await this.fetch()\n    data = data.filter(x => x.id !== entry.id)\n    data.push(entry)\n\n    await this.bp.ghost.forBot(this.botId).upsertFile('./', 'kb_content.json', JSON.stringify(data, undefined, 2))\n    this._data = [...data]\n  }\n\n  async fetch(): Promise<Entry[]> {\n    try {\n      if (!this._data) {\n        this._data = await this.bp.ghost.forBot(this.botId).readFileAsObject('./', 'kb_content.json')\n      }\n      return [...(this._data || [])]\n    } catch (err) {\n      this.bp.logger.attachError(err).warn('Could not retrieve KB data')\n      return []\n    }\n  }\n\n  async delete(ids: string[]) {\n    let data = await this.fetch()\n    data = data.filter(o => !ids.includes(o.id))\n    await this.bp.ghost.forBot(this.botId).upsertFile('./', 'kb_content.json', JSON.stringify(data, undefined, 2))\n  }\n\n  getDataHash(entries: Entry[]): string {\n    // hash of data/model = hash(entries[] -> ids + modified_on -> join(' + '))\n    return ''\n  }\n\n  async storeModel(model: Model): Promise<void> {\n    await this.bp.ghost.forBot(this.botId).upsertFile('./models', 'kb_latest.json', model.toJSON())\n    this._data = undefined\n  }\n\n  async loadLatestModel(): Promise<Model | undefined> {\n    try {\n      const modelData = await this.bp.ghost.forBot(this.botId).readFileAsString('./models', 'kb_latest.json')\n      if (!modelData || !modelData.length) {\n        throw new Error('Model not found')\n      }\n      return RemoteModel.fromJSON(modelData)\n    } catch (err) {\n      this.bp.logger.attachError(err).warn(`Could not load KB model`)\n    }\n  }\n}\n"]}